<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software Engineering on Bathysphere.org</title><link>https://www.bathysphere.org/tags/software-engineering/</link><description>Recent content in Software Engineering on Bathysphere.org</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 08 May 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://www.bathysphere.org/tags/software-engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>Embrace Limitations</title><link>https://www.bathysphere.org/p/embrace-limitations/</link><pubDate>Thu, 08 May 2025 00:00:00 +0000</pubDate><guid>https://www.bathysphere.org/p/embrace-limitations/</guid><description>&lt;img src="https://www.bathysphere.org/p/embrace-limitations/image.png" alt="Featured image of post Embrace Limitations" />&lt;h1 id="limited-systems-can-be-cheaper-and-better">Limited systems can be cheaper and better
&lt;/h1>&lt;p>Writing a robust, general-purpose system is often quite expensive. For example, the memory allocator behind &lt;code>malloc()&lt;/code> and &lt;code>new&lt;/code> is the result of years of work and fine-tuning. It has to handle every weird allocation pattern, be completely thread-safe on 64-core processors, minimize memory fragmentation and overhead, etc. If the memory allocator is inadequate for some reason and you feel the urge to write your own replacement, a starting assumption is that it will take you about as long as the original took - maybe quicker if you are very smart, longer if you are unfamiliar with the problem space. In many cases that&amp;rsquo;s impractical.&lt;/p>
&lt;p>However if you introduce the right limitation it can massively reduce the effort required. &lt;code>malloc&lt;/code> is partly complicated because the caller can allocate and deallocate any sized chunk of memory in any order, from any thread. An arena allocator has a different interface: the caller first creates an &lt;code>arena&lt;/code>, then allocates many small chunks of memory inside that arena, then deletes the arena when complete, invalidating and freeing all the small chunks at once. This works well if you need to allocate a number of temporary structures to process a request, then can dispose them all at the end. Usually the implementation is a big chunk of memory and a &lt;code>next&lt;/code> pointer. To allocate memory, just return the current value of &lt;code>next&lt;/code> and increment it by the number of bytes requested. The implementation can be a few hundred lines, and allocation will be very fast.&lt;/p>
&lt;p>Why is this cheaper to implement? Because we&amp;rsquo;ve embraced a limitation and produced a less general interface. The limitation here is on &lt;code>free()&lt;/code> - the caller can&amp;rsquo;t free individual memory chunks. That doesn&amp;rsquo;t seem like a huge difference, but it simplifies things a lot.&lt;/p>
&lt;h1 id="buy-general-purpose-build-special-purpose">Buy general-purpose, build special-purpose
&lt;/h1>&lt;p>It rarely makes sense to write your own very general-purpose subsystem (like custom programming language, database engine, memory allocator) if your main goal is to build an application - you likely can&amp;rsquo;t afford to do a good job of it.&lt;/p>
&lt;p>But &lt;em>if&lt;/em> the off-the-shelf components are not suitable, it may make sense to solve a &lt;em>specialized&lt;/em> subset of the problem: not a programming language but a tiny DSL; not a general-purpose allocator but an arena allocator. You can take advantage of the limitations you have embraced to simplify the implementation by orders of magnitude.&lt;/p>
&lt;h1 id="dont-evolve-your-special-purpose-system-to-make-it-more-general">Don&amp;rsquo;t evolve your special-purpose system to make it more general
&lt;/h1>&lt;p>So you successfully implemented your special-purpose DSL for mangling your custom data. Maybe it&amp;rsquo;s super fast and reliable because it has no looping constructs or branches so execution time is bounded. Everyone loves it. But then someone comes along and says &amp;ldquo;but you know, it would be really nice if we could do a loop here&amp;hellip;&amp;rdquo;. If you go ahead and kludge in a wonky looping construct, this is a classic blunder, like going up against a Sicilian when death is on the line. Now your system has lost its defining limitation, it is competing against general-purpose languages, and on those metrics it probably sucks - limited adoption, no debugger, no standard library, no ecosystem, and so on.&lt;/p>
&lt;p>This blunder is so classic it has its own &lt;a class="link" href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule" target="_blank" rel="noopener"
>Wikipedia article&lt;/a>. Don&amp;rsquo;t fall for it! Either stick with your limited system and embrace the limitations, or if the problem really is more general, you have to suck it up and adopt the &amp;lsquo;real&amp;rsquo; system.&lt;/p></description></item><item><title>Unofficial Safety-Critical Software</title><link>https://www.bathysphere.org/p/unofficial-safety/</link><pubDate>Sun, 30 Mar 2025 00:00:00 +0000</pubDate><guid>https://www.bathysphere.org/p/unofficial-safety/</guid><description>&lt;img src="https://www.bathysphere.org/p/unofficial-safety/safety.jpg" alt="Featured image of post Unofficial Safety-Critical Software" />&lt;p>Some computer systems are obviously safety-critical. If you are working on flight-control software for Boeing or Airbus, everyone involved is aware that mistakes in this program could cause loss of life. So software like this is written very, very carefully - extremely detailed specifications, often proofs of correctness using a theorem prover, exhaustive testing, and so on.&lt;/p>
&lt;p>But there are also cases where general-purpose software can wind up in a situation where bugs could cause dangerous consequences. I&amp;rsquo;m using &amp;ldquo;unofficial safety-critical software&amp;rdquo; quite loosely to refer to refer to this.&lt;/p>
&lt;p>For example, a web search turns up many resources like &lt;a class="link" href="https://www.snprs.scot.nhs.uk/?page_id=635" target="_blank" rel="noopener"
>https://www.snprs.scot.nhs.uk/?page_id=635&lt;/a>, which contains an Excel spreadsheet for calculating drug dosages, including for dangerous medications like fentanyl. If there are errors either in the Excel application itself, or in the spreadsheet, it doesn&amp;rsquo;t seem like a stretch to say that could kill a child. It&amp;rsquo;s not surprising that the web page says &lt;strong>&amp;ldquo;Disclaimer: this drug calculator is intended as an aid to management and must AT ALL TIMES be used in conjunction with local drug preparation, checking and administration policies&amp;rdquo;&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://www.bathysphere.org/p/unofficial-safety/dosage.png"
width="1423"
height="1136"
srcset="https://www.bathysphere.org/p/unofficial-safety/dosage_hu_ece146b3427a9959.png 480w, https://www.bathysphere.org/p/unofficial-safety/dosage_hu_8fe9364a116f447a.png 1024w"
loading="lazy"
alt="A screenshot of a spreadsheet for calculating drug dosages"
class="gallery-image"
data-flex-grow="125"
data-flex-basis="300px"
>&lt;/p>
&lt;p>I don&amp;rsquo;t mean by this to call out either the people who made this calculator, or Microsoft, as having done something wrong. I don&amp;rsquo;t have any firm conclusions at all, but likely this is a lot safer than calculating things by hand.&lt;/p>
&lt;p>But it raises some interesting questions.&lt;/p>
&lt;ul>
&lt;li>Is Excel &amp;ldquo;unofficial safety-critical software&amp;rdquo;? Is the spreadsheet itself USCC?&lt;/li>
&lt;li>How about any sufficiently-powerful program, like a programming language or MATLAB, which could be used for life-or-death calculations?&lt;/li>
&lt;li>If calculating dosages in a spreadsheet is too dangerous, what would we recommend instead?&lt;/li>
&lt;li>How do we distribute responsibility for correctness between Excel, the spreadsheet author, and the physician using the spreadsheet? Excel&amp;rsquo;s EULA and the web page disclaimer push the responsibility entirely to the end user. Is that reasonable?&lt;/li>
&lt;li>Is the software I work on unofficially safety-critical? Should that change my approach?&lt;/li>
&lt;/ul></description></item><item><title>Deferred Maintenance is a better metaphor than Technical Debt</title><link>https://www.bathysphere.org/p/deferred-maintenance/</link><pubDate>Sun, 24 Apr 2022 00:00:00 +0000</pubDate><guid>https://www.bathysphere.org/p/deferred-maintenance/</guid><description>&lt;img src="https://www.bathysphere.org/p/deferred-maintenance/image.png" alt="Featured image of post Deferred Maintenance is a better metaphor than Technical Debt" />&lt;p>There&amp;rsquo;s a lot of discussion about Technical Debt in Software Engineering. I believe the term originated &lt;a class="link" href="http://wiki.c2.com/?TechnicalDebt" target="_blank" rel="noopener"
>on the C2 wiki&lt;/a>. It&amp;rsquo;s often used to explain to non-software-engineers why it&amp;rsquo;s important to invest in code quality.&lt;/p>
&lt;p>I&amp;rsquo;m far from the first person to think that the term Technical Debt is potentially misleading. Rob Jeffries has a discussion &lt;a class="link" href="https://ronjeffries.com/articles/015-11/tech-debt/" target="_blank" rel="noopener"
>here&lt;/a>.&lt;/p>
&lt;p>To oversimplify, debt involves interest payments. These compound over time, occur at predictable intervals, can be paid off, and cost a fairly predictable amount of money. None of these are true when you decide to take shortcuts in software: the passage of time has no direct compounding effect, and you don&amp;rsquo;t know when the bill will come due or how expensive it will be.&lt;/p>
&lt;p>This mismatch between the term and the implications can be a problem if it conveys the wrong impression to our non-software colleague.&lt;/p>
&lt;p>I like the term &lt;em>deferred maintenance&lt;/em> better. This is also an inexact metaphor but I think it&amp;rsquo;s closer. Anyone who has owned a car understands that it needs maintenance. If you don&amp;rsquo;t change the oil at regular intervals, the car will gradually run more slowly and roughly. Eventually, at an upredictable time, the engine will seize up and you&amp;rsquo;ll be faced with a large and unpredictable bill to replace the entire thing. If you don&amp;rsquo;t service the brakes, the results can be significantly worse. Consider a 747 instead of a Corolla if you really want to emphasize the importance of maintenance.&lt;/p>
&lt;p>You can extend this notion to help justify the idea of scheduling time explicitly for maintenance activity, like a monthly or quarterly &amp;rsquo;tune-up'.&lt;/p>
&lt;p>Bottom line: if you have a large piece of software which is not maintained, you own a very complicated machine which is not performing as well as it could, and might break down at any point.&lt;/p></description></item></channel></rss>